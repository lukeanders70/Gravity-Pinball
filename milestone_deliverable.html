
<html>
	<head>

	</head>

	<body>
		<h1> Gravitational Pinball: Milestone </h1>
		<h2> interactive gravity simulation running in real time in webGL </h2>

		<h2> Accomplishments </h2>

		<ul>
			<li>
				<h3>WebGL Running</h3>
				<p>It was important to us that we make our project more or less from scratch. The Ray Tracing 2 projects included a section on WebGL that might well have served as a starting point, but one of the main reasons for choosing this particular focus for our project was out of a desire to really learn the framework from the ground up. As such, a good portion of the first part of our project (which we thankfully allocated time for) was in getting WebGL up and running. The framework has a relativly high upfront cost of on the order of 100 lines of code to render a stationary triangle, so writting and understanding these setup steps was a big hurdle to getting started.
			</li>
			<li>
				<h3>Rendering Spheres</h3>
				<p> Once we were able to render a triangle in 3D space, our next step was to encode the rendering of a sphere, which is the shape of most of the objects we will be rendering throughout the project. We, again, elected to do this from scratch. Out method involved forming a sphere from triangles by dividing the sphere into latitudes and logitudes, much like you would a real planet. A constructor funciton takes in the number of latitudinal lines and logitudinal lines of the desired output sphere. We then iterate across two angles: directly up (towards the north pole) to 180 degrees in the other direction, and directly out along the x axis, all the way back around 360 degrees. For example, if we wish to only have 1 latitude line and 4 longitude lines (this owuld look like a diamond shape) our first angle would start at 0, then 90, then 180 and our second angle would start at 0, then 90, then 180, then 270, then 360. In general, each section of the iteration will give us a quadrilateral segment on the surface of the sphere which we will fill with two triangles. 
			</li>
			<li>
				<h3>Simulating Gravity</h3>
				<p> The Primary portion of our project involves simulating gravity. In addition to the triangles which make up a sphere, we give spheres a number of other properites including mass. This allows us to to calculate forces which will move the spheres in relation to one another. Because we have each sphere's mass, to calculate the total force we will simply interate through all of the other spheres and calculate the force of gravity between them
				</p>

				<i><sup>(G * M<sub>1</sub> * M<sub>2</sub>)</sup>&frasl;<sub>r<sup>2</sup></sub></i>

				<p>The direction of this force will of course be the unit vector pointing from the sphere of interests center, to the center of the other sphere. Once we have net force acting on a sphere, we can get its acceleration by simply dividing my it's mass. We can also get a good approximation of it's velocity by taking the difference between it's last positing and it's current position. Through these peices, we can solve for the sphere's new positiong by substituting these values into the formula: 
				</p>

				<i>X<sub>new</sub> = X<sub>old</sub> + V*t + A*t<sup>2</sup></i>

				<p> Where the time is simply derived from our framerate. With all of these peices we have a fairly robust gravity simulation from which we can see emergant properties such as planet orbits, and Kepler's laws of planetary motion.</p>
			</li>
			<li>
				<h3>Planet Collisions</h3>

				<p> Up until this point, planets are able to clip through each other. In addition to looking strange, this has an unforntunate consequence of two planet centers coming arbitrarily close together and the force between them nearing infinity. In order to rectify this, we impliment a 'bouncing' feature. When two planets clip through one another (that is, a planet is moved such that it the distance between it's center and the center of another planet is less than the sum of their radii), instead of applying an attractive gravitation force between them, we apply a repelling force. <p>
			</li>
		</ul>
	</body>
</html>