<html>
	<head>
		<title>WebGL</title>
		<link rel="stylesheet" type="text/css" href="style.css">
	</head>

	<body onload="InitDemo();">
		<canvas id="render_canvas">
			Your Browser Does not support WebGl
		</canvas>
		<br />

		<i> Canvas is above this text </i>
		<script src="app.js"></script>
		<script src="gl-matrix.js"></script>

		<!-- Vertex Shader for WebGL, not to be rendered-->
		<script type="text/javascript">
			var num_lat = 4.0;
			var num_lon = 8.0;
			var center = [0.0, 0.0, 0.0];
			var vertices = [];
			var r = 1.0;

			for (let lat = 1.0; lat <= num_lat; ++lat) {
				for (let lon = 0.0; lon < num_lon; ++lon) {
					let a1 = (lat / (num_lat + 1)) * Math.PI; //radians away from straight up
					let a2 = (lon / (num_lon)) * Math.PI * 2.0; //radians aorund circle

					let x00 = center[0] + (r * Math.sin(a2) * Math.sin(a1));
					let y00 = center[1] + (r * Math.cos(a1));
					let z00 = center[2] + (r * Math.sin(a1) * Math.cos(a2));


					let a3 = (lat / (num_lat + 1)) * Math.PI; //radians away from straight up
					let a4 = ((lon + 1.0)/ (num_lon)) * Math.PI * 2.0; //radians aorund circle

					let x10 = center[0] + (r * Math.sin(a4) * Math.sin(a3));
					let y10 = center[1] + (r * Math.cos(a3));
					let z10 = center[2] + (r * Math.sin(a3) * Math.cos(a4));


					let a5 = ((lat-1.0) / (num_lat + 1)) * Math.PI; //radians away from straight up
					let a6 = ((lon + 1.0)/ (num_lon)) * Math.PI * 2.0; //radians aorund circle

					let x11 = center[0] + (r * Math.sin(a6) * Math.sin(a5));
					let y11 = center[1] + (r * Math.cos(a5));
					let z11 = center[2] + (r * Math.sin(a5) * Math.cos(a6));


					let a7 = ((lat-1.0) / (num_lat + 1)) * Math.PI; //radians away from straight up
					let a8 = ((lon)/ (num_lon)) * Math.PI * 2.0; //radians aorund circle

					let x01 = center[0] + (r * Math.sin(a8) * Math.sin(a7));
					let y01 = center[1] + (r * Math.cos(a7));
					let z01 = center[2] + (r * Math.sin(a7) * Math.cos(a8));

/*					console.log(a1, a2, a3, a4, a5, a6, a7, a8);
					console.log(x00, y00, z00);
					console.log(x10, y10, z10);
					console.log(x11, y11, z11);
					console.log(x01, y01, z01);*/


					vertices.push(x00)
					vertices.push(y00)
					vertices.push(z00)

					vertices.push(x10)
					vertices.push(y10)
					vertices.push(z10)

					vertices.push(x01)
					vertices.push(y01)
					vertices.push(z01)


					vertices.push(x10)
					vertices.push(y10)
					vertices.push(z10)

					vertices.push(x11)
					vertices.push(y11)
					vertices.push(z11)

					vertices.push(x01)
					vertices.push(y01)
					vertices.push(z01)
				}
			}
		</script>
		<script id="vertex_shader" type="not-javascript">
			precision mediump float;

			attribute vec3 vertPosition;
			attribute vec3 vertColor;
			varying vec3 fragColor;
			uniform mat4 world_matrix_render;
			uniform mat4 view_matrix_render;
			uniform mat4 projection_matrix_render;

			void main(){
				fragColor = vertColor;
				gl_Position = projection_matrix_render * view_matrix_render * world_matrix_render * vec4(vertPosition, 1.0);
			}
		</script>

		<!-- Fragment Shader for WebGL, not to be rendered-->
		<script id="fragment_shader" type="not-javascript">
			precision mediump float;

			varying vec3 fragColor;

			void main(){
				gl_FragColor = vec4(fragColor, 1.0);
			}
		</script>

	</body>

</html>